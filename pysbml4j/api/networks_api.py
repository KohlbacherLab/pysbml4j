# coding: utf-8

"""
    sbml4j API

    This is the api for the SBML4j Service   # noqa: E501

    OpenAPI spec version: 1.1.4
    Contact: thorsten.tiede@uni-tuebingen.de
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from pysbml4j.api_client import ApiClient


class NetworksApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_annotation_to_network(self, body, user, uuid, **kwargs):  # noqa: E501
        """Add annotation to network nodes and/or relationships. Results in the creation of a new network entity, keeping the entity with UUID unchanged.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_annotation_to_network(body, user, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AnnotationItem body: The fields of the AnnotationItem are used to create annotations in a network as follows:

Must provide 
- either all fields associated with nodes (nodeAnnotation, nodeAnnotationName, nodeAnnotationType)
- or all fields associated wth relations (relationAnnotation, relationAnnotationName, relationAnnotationType) 
- or both.

Fields related to nodes:
- nodeAnnotationName denotes the name under which the annotations in the nodeAnnotation field of the request body are attached to nodes
 
- nodeAnnotationType is used as type with which the annotations in the nodeAnnotation field of the request body are attached to nodes. Is also used to read out the annotation in said format when extracting network
 
- nodeAnnotation is a dictionary of "node-symbol": "annotation" - pairs where node-symbol must match one of the node symbols in the network (see field nodeSymbols in FilterOptions); the annotation is added to the node under the name defined in nodeAnnotationName using the type in nodeAnnotationType
 

 
Fields related to relations:
- relationAnnotationName denotes the name under which the annotations in the relationAnnotation field of the request body are attached to relations
 
- relationAnnotationType is used as type with which the annotations in the relationAnnotation field of the request body are attached to relations. Is also used to read out the annotation in said format when extracting network
- relationAnnotation is a dictionary of "relation-symbol": "annotation" - pairs where realation-symbol must match one of the relation symbols in the network (see field relationSymbols in FilterOptions); the annotation is added to the relation under the name defined in relationAnnotationName using the type in relationAnnotationType
 (required)
        :param str user: The user which requests the creation (required)
        :param str uuid: The UUID of the parent network to derive a new network from (required)
        :param bool derive: Flag whether to derive a new network and add annotation to it (true) or add annotation to existing network without deriving subnetwork (false)
        :return: NetworkInventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_annotation_to_network_with_http_info(body, user, uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.add_annotation_to_network_with_http_info(body, user, uuid, **kwargs)  # noqa: E501
            return data

    def add_annotation_to_network_with_http_info(self, body, user, uuid, **kwargs):  # noqa: E501
        """Add annotation to network nodes and/or relationships. Results in the creation of a new network entity, keeping the entity with UUID unchanged.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_annotation_to_network_with_http_info(body, user, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AnnotationItem body: The fields of the AnnotationItem are used to create annotations in a network as follows:

Must provide 
- either all fields associated with nodes (nodeAnnotation, nodeAnnotationName, nodeAnnotationType)
- or all fields associated wth relations (relationAnnotation, relationAnnotationName, relationAnnotationType) 
- or both.

Fields related to nodes:
- nodeAnnotationName denotes the name under which the annotations in the nodeAnnotation field of the request body are attached to nodes
 
- nodeAnnotationType is used as type with which the annotations in the nodeAnnotation field of the request body are attached to nodes. Is also used to read out the annotation in said format when extracting network
 
- nodeAnnotation is a dictionary of "node-symbol": "annotation" - pairs where node-symbol must match one of the node symbols in the network (see field nodeSymbols in FilterOptions); the annotation is added to the node under the name defined in nodeAnnotationName using the type in nodeAnnotationType
 

 
Fields related to relations:
- relationAnnotationName denotes the name under which the annotations in the relationAnnotation field of the request body are attached to relations
 
- relationAnnotationType is used as type with which the annotations in the relationAnnotation field of the request body are attached to relations. Is also used to read out the annotation in said format when extracting network
- relationAnnotation is a dictionary of "relation-symbol": "annotation" - pairs where realation-symbol must match one of the relation symbols in the network (see field relationSymbols in FilterOptions); the annotation is added to the relation under the name defined in relationAnnotationName using the type in relationAnnotationType
 (required)
        :param str user: The user which requests the creation (required)
        :param str uuid: The UUID of the parent network to derive a new network from (required)
        :param bool derive: Flag whether to derive a new network and add annotation to it (true) or add annotation to existing network without deriving subnetwork (false)
        :return: NetworkInventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'user', 'uuid', 'derive']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_annotation_to_network" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_annotation_to_network`")  # noqa: E501
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `add_annotation_to_network`")  # noqa: E501
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `add_annotation_to_network`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['UUID'] = params['uuid']  # noqa: E501

        query_params = []
        if 'derive' in params:
            query_params.append(('derive', params['derive']))  # noqa: E501

        header_params = {}
        if 'user' in params:
            header_params['user'] = params['user']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['network_auth']  # noqa: E501

        return self.api_client.call_api(
            '/networks/{UUID}/annotation', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetworkInventoryItem',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_my_drug_relations(self, user, uuid, my_drug_url, **kwargs):  # noqa: E501
        """Provide a URL to a MyDrug Neo4j Database and add Drug nodes and Drug-targets->Gene Relationships to a network  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_my_drug_relations(user, uuid, my_drug_url, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user which requests the creation (required)
        :param str uuid: The UUID of the network that the myDrug Data should be added to. A copy will be created. (required)
        :param str my_drug_url: A base url of a MyDrug Database including the port number (required)
        :return: NetworkInventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_my_drug_relations_with_http_info(user, uuid, my_drug_url, **kwargs)  # noqa: E501
        else:
            (data) = self.add_my_drug_relations_with_http_info(user, uuid, my_drug_url, **kwargs)  # noqa: E501
            return data

    def add_my_drug_relations_with_http_info(self, user, uuid, my_drug_url, **kwargs):  # noqa: E501
        """Provide a URL to a MyDrug Neo4j Database and add Drug nodes and Drug-targets->Gene Relationships to a network  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_my_drug_relations_with_http_info(user, uuid, my_drug_url, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user which requests the creation (required)
        :param str uuid: The UUID of the network that the myDrug Data should be added to. A copy will be created. (required)
        :param str my_drug_url: A base url of a MyDrug Database including the port number (required)
        :return: NetworkInventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'uuid', 'my_drug_url']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_my_drug_relations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `add_my_drug_relations`")  # noqa: E501
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `add_my_drug_relations`")  # noqa: E501
        # verify the required parameter 'my_drug_url' is set
        if ('my_drug_url' not in params or
                params['my_drug_url'] is None):
            raise ValueError("Missing the required parameter `my_drug_url` when calling `add_my_drug_relations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['UUID'] = params['uuid']  # noqa: E501

        query_params = []
        if 'my_drug_url' in params:
            query_params.append(('myDrugURL', params['my_drug_url']))  # noqa: E501

        header_params = {}
        if 'user' in params:
            header_params['user'] = params['user']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/networks/{UUID}/myDrug', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetworkInventoryItem',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def copy_network(self, user, uuid, **kwargs):  # noqa: E501
        """Create a copy of the network with uuid UUID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_network(user, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user which requests the creation (required)
        :param str uuid: The UUID of the parent network to be copied (required)
        :return: NetworkInventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.copy_network_with_http_info(user, uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_network_with_http_info(user, uuid, **kwargs)  # noqa: E501
            return data

    def copy_network_with_http_info(self, user, uuid, **kwargs):  # noqa: E501
        """Create a copy of the network with uuid UUID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_network_with_http_info(user, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user which requests the creation (required)
        :param str uuid: The UUID of the parent network to be copied (required)
        :return: NetworkInventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_network" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `copy_network`")  # noqa: E501
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `copy_network`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['UUID'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}
        if 'user' in params:
            header_params['user'] = params['user']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['network_auth']  # noqa: E501

        return self.api_client.call_api(
            '/networks/{UUID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetworkInventoryItem',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_network(self, user, uuid, **kwargs):  # noqa: E501
        """Request the deletion of a network  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_network(user, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user which requests deletion of their network (required)
        :param str uuid: The UUID of the network to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_network_with_http_info(user, uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_network_with_http_info(user, uuid, **kwargs)  # noqa: E501
            return data

    def delete_network_with_http_info(self, user, uuid, **kwargs):  # noqa: E501
        """Request the deletion of a network  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_network_with_http_info(user, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user which requests deletion of their network (required)
        :param str uuid: The UUID of the network to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_network" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `delete_network`")  # noqa: E501
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `delete_network`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['UUID'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}
        if 'user' in params:
            header_params['user'] = params['user']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['network_auth']  # noqa: E501

        return self.api_client.call_api(
            '/networks/{UUID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def filter_network(self, body, user, uuid, **kwargs):  # noqa: E501
        """Filter a network according to the request body options. Results in the creation of a new network entity, keeping the entity with UUID unchanged.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filter_network(body, user, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FilterOptions body: The filterOptions to be used in the step upon creation.

- NodeSymbols: Only nodes listed here can be part of the network (and if they match given nodeTypes)
 
- NodeTypes: Only nodes having one of the listed nodesTypes here can be part of the network (and if they are contained in NodeSymbols)
 
- RelationSymbols: Only relations listed here can be part of the network (and if they match given relationTypes)
 
- RelationTypes: Only edges having one of the listed relationTypes here can be part of the network

  
 (required)
        :param str user: The user which requests the creation (required)
        :param str uuid: The UUID of the parent network to derive a new network from (required)
        :return: NetworkInventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.filter_network_with_http_info(body, user, uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.filter_network_with_http_info(body, user, uuid, **kwargs)  # noqa: E501
            return data

    def filter_network_with_http_info(self, body, user, uuid, **kwargs):  # noqa: E501
        """Filter a network according to the request body options. Results in the creation of a new network entity, keeping the entity with UUID unchanged.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.filter_network_with_http_info(body, user, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FilterOptions body: The filterOptions to be used in the step upon creation.

- NodeSymbols: Only nodes listed here can be part of the network (and if they match given nodeTypes)
 
- NodeTypes: Only nodes having one of the listed nodesTypes here can be part of the network (and if they are contained in NodeSymbols)
 
- RelationSymbols: Only relations listed here can be part of the network (and if they match given relationTypes)
 
- RelationTypes: Only edges having one of the listed relationTypes here can be part of the network

  
 (required)
        :param str user: The user which requests the creation (required)
        :param str uuid: The UUID of the parent network to derive a new network from (required)
        :return: NetworkInventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'user', 'uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method filter_network" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `filter_network`")  # noqa: E501
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `filter_network`")  # noqa: E501
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `filter_network`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['UUID'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}
        if 'user' in params:
            header_params['user'] = params['user']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['network_auth']  # noqa: E501

        return self.api_client.call_api(
            '/networks/{UUID}/filter', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetworkInventoryItem',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_context(self, user, uuid, genes, **kwargs):  # noqa: E501
        """Get network context of one or multiple genes in the network with uuid {UUID}  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_context(user, uuid, genes, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: (required)
        :param str uuid: The UUID of the network that serves as a basis for this context (required)
        :param str genes: (required)
        :param int min_size: The minimum depth of the context search
        :param int max_size: The maximum depth of the context search
        :param bool terminate_at_drug: allows to restrict the context search to only show paths that end in a drug node (MyDrug annotations are required for this)
        :param str direction: The direction of the context expansion (upstream, downstream, both)
        :param bool directed: Denotes whether the return network graph is directed
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_context_with_http_info(user, uuid, genes, **kwargs)  # noqa: E501
        else:
            (data) = self.get_context_with_http_info(user, uuid, genes, **kwargs)  # noqa: E501
            return data

    def get_context_with_http_info(self, user, uuid, genes, **kwargs):  # noqa: E501
        """Get network context of one or multiple genes in the network with uuid {UUID}  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_context_with_http_info(user, uuid, genes, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: (required)
        :param str uuid: The UUID of the network that serves as a basis for this context (required)
        :param str genes: (required)
        :param int min_size: The minimum depth of the context search
        :param int max_size: The maximum depth of the context search
        :param bool terminate_at_drug: allows to restrict the context search to only show paths that end in a drug node (MyDrug annotations are required for this)
        :param str direction: The direction of the context expansion (upstream, downstream, both)
        :param bool directed: Denotes whether the return network graph is directed
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'uuid', 'genes', 'min_size', 'max_size', 'terminate_at_drug', 'direction', 'directed']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_context" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `get_context`")  # noqa: E501
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `get_context`")  # noqa: E501
        # verify the required parameter 'genes' is set
        if ('genes' not in params or
                params['genes'] is None):
            raise ValueError("Missing the required parameter `genes` when calling `get_context`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['UUID'] = params['uuid']  # noqa: E501

        query_params = []
        if 'genes' in params:
            query_params.append(('genes', params['genes']))  # noqa: E501
        if 'min_size' in params:
            query_params.append(('minSize', params['min_size']))  # noqa: E501
        if 'max_size' in params:
            query_params.append(('maxSize', params['max_size']))  # noqa: E501
        if 'terminate_at_drug' in params:
            query_params.append(('terminateAtDrug', params['terminate_at_drug']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501
        if 'directed' in params:
            query_params.append(('directed', params['directed']))  # noqa: E501

        header_params = {}
        if 'user' in params:
            header_params['user'] = params['user']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['network_auth']  # noqa: E501

        return self.api_client.call_api(
            '/networks/{UUID}/context', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_network(self, user, uuid, **kwargs):  # noqa: E501
        """Retrieve the contents of a network  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_network(user, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user which requests the creation (required)
        :param str uuid: The UUID of the network to get (required)
        :param bool directed: Boolean flag wether the resulting network-graph should be directed 
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_network_with_http_info(user, uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_network_with_http_info(user, uuid, **kwargs)  # noqa: E501
            return data

    def get_network_with_http_info(self, user, uuid, **kwargs):  # noqa: E501
        """Retrieve the contents of a network  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_network_with_http_info(user, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user which requests the creation (required)
        :param str uuid: The UUID of the network to get (required)
        :param bool directed: Boolean flag wether the resulting network-graph should be directed 
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'uuid', 'directed']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_network" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `get_network`")  # noqa: E501
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `get_network`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['UUID'] = params['uuid']  # noqa: E501

        query_params = []
        if 'directed' in params:
            query_params.append(('directed', params['directed']))  # noqa: E501

        header_params = {}
        if 'user' in params:
            header_params['user'] = params['user']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['network_auth']  # noqa: E501

        return self.api_client.call_api(
            '/networks/{UUID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_network_options(self, user, uuid, **kwargs):  # noqa: E501
        """Get available options for network  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_network_options(user, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: (required)
        :param str uuid: The network UUID for which the networkOptions are to be fetched (required)
        :return: NetworkOptions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_network_options_with_http_info(user, uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_network_options_with_http_info(user, uuid, **kwargs)  # noqa: E501
            return data

    def get_network_options_with_http_info(self, user, uuid, **kwargs):  # noqa: E501
        """Get available options for network  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_network_options_with_http_info(user, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: (required)
        :param str uuid: The network UUID for which the networkOptions are to be fetched (required)
        :return: NetworkOptions
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_network_options" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `get_network_options`")  # noqa: E501
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `get_network_options`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['UUID'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}
        if 'user' in params:
            header_params['user'] = params['user']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['network_auth']  # noqa: E501

        return self.api_client.call_api(
            '/networks/{UUID}/options', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetworkOptions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_all_networks(self, user, **kwargs):  # noqa: E501
        """List available networks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_all_networks(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user which requests listing of their networks (required)
        :return: list[NetworkInventoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_all_networks_with_http_info(user, **kwargs)  # noqa: E501
        else:
            (data) = self.list_all_networks_with_http_info(user, **kwargs)  # noqa: E501
            return data

    def list_all_networks_with_http_info(self, user, **kwargs):  # noqa: E501
        """List available networks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_all_networks_with_http_info(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: The user which requests listing of their networks (required)
        :return: list[NetworkInventoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_all_networks" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `list_all_networks`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'user' in params:
            header_params['user'] = params['user']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['network_auth']  # noqa: E501

        return self.api_client.call_api(
            '/networks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[NetworkInventoryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_context(self, body, user, uuid, **kwargs):  # noqa: E501
        """Create network context of one or multiple genes in the network with uuid {UUID}  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_context(body, user, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NodeList body: The genes for which the context should be generated
 (required)
        :param str user: (required)
        :param str uuid: The UUID of the network that serves as a basis for this context (required)
        :param int min_size: The minimum depth of the context search
        :param int max_size: The maximum depth of the context search
        :param bool terminate_at_drug: allows to restrict the context search to only show paths that end in a drug node (MyDrug annotations are required for this)
        :param str direction: The direction of the context expansion (upstream, downstream, both)
        :return: NetworkInventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_context_with_http_info(body, user, uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.post_context_with_http_info(body, user, uuid, **kwargs)  # noqa: E501
            return data

    def post_context_with_http_info(self, body, user, uuid, **kwargs):  # noqa: E501
        """Create network context of one or multiple genes in the network with uuid {UUID}  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_context_with_http_info(body, user, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NodeList body: The genes for which the context should be generated
 (required)
        :param str user: (required)
        :param str uuid: The UUID of the network that serves as a basis for this context (required)
        :param int min_size: The minimum depth of the context search
        :param int max_size: The maximum depth of the context search
        :param bool terminate_at_drug: allows to restrict the context search to only show paths that end in a drug node (MyDrug annotations are required for this)
        :param str direction: The direction of the context expansion (upstream, downstream, both)
        :return: NetworkInventoryItem
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'user', 'uuid', 'min_size', 'max_size', 'terminate_at_drug', 'direction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_context" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_context`")  # noqa: E501
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `post_context`")  # noqa: E501
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `post_context`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['UUID'] = params['uuid']  # noqa: E501

        query_params = []
        if 'min_size' in params:
            query_params.append(('minSize', params['min_size']))  # noqa: E501
        if 'max_size' in params:
            query_params.append(('maxSize', params['max_size']))  # noqa: E501
        if 'terminate_at_drug' in params:
            query_params.append(('terminateAtDrug', params['terminate_at_drug']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501

        header_params = {}
        if 'user' in params:
            header_params['user'] = params['user']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/networks/{UUID}/context', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NetworkInventoryItem',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
